@using System.Reflection
@using System.Text.Json
@using System.Collections.Generic
@using System.Collections.Specialized
@using System.Linq.Expressions
@using LogiEdge.CustomerService.Data
@using LogiEdge.WarehouseService.Data
@using Microsoft.AspNetCore.Components.Forms
@code {
    [Parameter]
    public required IList<Item> Items { get; set; }
    [Parameter]
    public DateTime? AtDate { get; set; }
    [Parameter]
    public required OrderedDictionary<string, bool> PropertyColumns { get; set; }
    /// <summary>
    /// Name of the column to sort by.
    /// </summary>
    [Parameter]
    public string? SortByColumn { get; set; } = null;
    /// <summary>
    /// If false, sort in ascending order. If true, sort in descending order
    /// </summary>
    [Parameter]
    public bool SortOrderDescending { get; set; } = false;

    [Parameter]
    public EventCallback<OrderedDictionary<string, bool>> DisplayedPropertyColumnsChangeRequested { get; set; }

    [Parameter]
    public EventCallback<(string? sortByColumn, bool sortDescending)> SortOrderChangeRequested { get; set; }

    private OrderedDictionary<string, bool>? modalPropertyColumns = null;
    private List<DraggableList<string>.ListItem> propertyListItems = [];

    private RenderFragment<(string propertyName, object? propertyValue)> propertyRenderFragment = (ValueTuple<string, object?> data) =>
    {
        (string propertyName, object? propertyValue) = data;

        if (propertyValue == null)
            return @<td>null</td>;

        switch (propertyName)
        {
            case nameof(Item.Customer):
                Customer c = (Customer)propertyValue;
                return @<td>@c.Name</td>;
            case nameof(ItemState.Warehouse):
                Warehouse w = (Warehouse)propertyValue;
                return @<td>@w.Name</td>;
            default:
                return @<td>@(propertyValue.ToString())</td>;
        }
    };

    private void BtnSortClicked(string columnName)
    {
        // sort the column in ascending order if it is not already sorted by it
        bool descending = (SortByColumn == columnName) && !SortOrderDescending;

        SortOrderChangeRequested.InvokeAsync((columnName, descending));
    }
}

@{
    modalPropertyColumns ??= new(PropertyColumns);
}

<span>Showing @Items.Count items.</span>
<table class="table table-striped table-hover">
    <thead class="table-primary">
        <tr>
            @foreach ((string propertyName, bool _) in PropertyColumns.Where(x => x.Value))
            {
                <th style="line-height: 24px;">
                    <span style="vertical-align: bottom;">@propertyName</span>

                    <button type="button"
                            class="btn btn-secondary table-button"
                            @onclick="() => BtnSortClicked(propertyName)">
                        @if (SortByColumn == propertyName)
                        {
                            @if (SortOrderDescending)
                            {
                                <span class="material-symbols-rounded">
                                    arrow_upward
                                </span>
                            }
                            else
                            {
                                <span class="material-symbols-rounded">
                                    arrow_downward
                                </span>
                            }
                        }
                        else
                        {
                            <span class="material-symbols-rounded">
                                swap_vert
                            </span>
                        }
                    </button>

                    @if (propertyName == PropertyColumns.Last(x => x.Value).Key)
                    {
                        // button to select which columns to show
                        <button type="button"
                                class="btn btn-primary table-button"
                                style="float: right;"
                                data-bs-toggle="modal"
                                data-bs-target="#modal-column-select">
                            <span class="material-symbols-rounded">
                                splitscreen_vertical_add
                            </span>
                        </button>
                    }
                </th>
            }
        </tr>
    </thead>
    <tbody>
        @{
            IList<Item> sortedItems = Items;

            if (SortByColumn != null)
            {
                PropertyInfo? itemProperty = typeof(Item).GetProperty(SortByColumn);
                PropertyInfo? stateProperty = typeof(ItemState).GetProperty(SortByColumn);

                if (itemProperty == null && stateProperty == null)
                {
                    <p>Property @SortByColumn to sort by could not be found.</p>
                    return;
                }

                object? Lambda(Item it) => itemProperty != null
                ? itemProperty.GetValue(it)
                : stateProperty!.GetValue(it.ItemStates.Where(st => !AtDate.HasValue || st.Date <= AtDate.Value).MaxBy(st => st.Date));
                if (SortOrderDescending)
                {

                    sortedItems = sortedItems
                    .OrderByDescending(Lambda)
                    .ToList();
                }
                else
                {
                    sortedItems = sortedItems
                    .OrderBy(Lambda)
                    .ToList();
                }
            }
        }
        @foreach (Item item in sortedItems)
        {
            ItemState? itemState = item.ItemStates.Where(st => !AtDate.HasValue || st.Date <= AtDate.Value).MaxBy(st => st.Date);

            // if there is no item state before the given date that means the item wasn't in the warehouse at this
            // point in time, so skip it
            if (itemState == null)
                continue;

            <tr>
                @foreach (string propertyName in PropertyColumns.Where(x => x.Value).Select(x => x.Key))
                {
                    PropertyInfo? itemProperty = item.GetType().GetProperty(propertyName);
                    object? propertyValue = null;
                    if (itemProperty != null)
                    {
                        propertyValue = itemProperty.GetValue(item);
                    }
                    else
                    {
                        PropertyInfo? stateProperty = itemState.GetType().GetProperty(propertyName);
                        propertyValue = stateProperty?.GetValue(itemState);
                    }

                    @propertyRenderFragment((propertyName, propertyValue))
                }
            </tr>
        }
    </tbody>
</table>

<div class="modal" id="modal-column-select" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Table Columns</h5>
                <button type="button"
                        class="btn-close"
                        data-bs-dismiss="modal"
                        aria-label="Close"
                        @onclick="() => DisplayedPropertyColumnsChangeRequested.InvokeAsync(
                            new OrderedDictionary<string, bool>(
                                modalPropertyColumns.OrderBy(x => propertyListItems.First(y => y.BackingElement == x.Key).Order).ToList()))">
                </button>
            </div>
            <div class="modal-body">
                <p style="width: 100%; text-align: center;">Select columns to display in the table. Drag the handles to change column order.</p>
                <div id="modal-property-list" class="rounded border">
                    @{
                        RenderFragment<string> listItemFragment = item => @<span>
                            <InputCheckbox @bind-Value="modalPropertyColumns[item]" />
                            <label>@item</label>
                        </span>;
                        propertyListItems.Clear();
                        foreach (string propertyName in PropertyColumns.Keys)
                        {
                            propertyListItems.Add(new DraggableList<string>.ListItem
                {
                    Order = PropertyColumns.Keys.ToList().IndexOf(propertyName),
                    ListElement = listItemFragment,
                    BackingElement = propertyName
                });
                        }
                    }

                    <DraggableList TItem="string" Items="propertyListItems" Style="list-style-type: none;"></DraggableList>
                </div>
            </div>
        </div>
    </div>
</div>