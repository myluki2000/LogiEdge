@page "/items"
@using System.Linq.Expressions
@using System.Reflection
@using System.Text.Json
@using System.Text.Json.Nodes
@using LogiEdge.CustomerService.Data
@using LogiEdge.Shared
@using LogiEdge.Shared.Attributes
@using LogiEdge.Shared.Utility
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Persistence
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.EntityFrameworkCore
@using LogiEdge.Warehouse.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Primitives
@inject IDbContextFactory<WarehouseDbContext> WarehouseDbContextFactory
@inject NavigationManager NavigationManager

<h3>Items by Property</h3>

@code {
    protected override void OnInitialized()
    {
        base.OnInitialized();

        // necessary to refresh the page if the query parameters change
        NavigationManager.LocationChanged += (sender, args) => StateHasChanged();
    }

    private string? badgeEditingParamName = null;

    private static readonly ParameterExpression itemParameterExpression = Expression.Parameter(typeof(Item), "it");
    private static readonly MethodInfo jsonContainsMethod = typeof(NpgsqlJsonDbFunctionsExtensions)
        .GetMethod(nameof(NpgsqlJsonDbFunctionsExtensions.JsonContains), [typeof(DbFunctions), typeof(JsonDocument), typeof(JsonDocument)])!;
    private static readonly ParameterExpression itemStateParameterExpression = Expression.Parameter(typeof(ItemState), "st");

    private static Expression GenerateTypeConvertingConstantExpression(MemberExpression memberExpression, KeyValuePair<string, string> param)
    {
        object convertedParam = memberExpression.Type switch
        {
            { } t when t == typeof(int) => int.Parse(param.Value),
            { } t when t == typeof(decimal) => decimal.Parse(param.Value),
            { } t when t == typeof(DateTime) => DateTime.Parse(param.Value),
            { } t when t == typeof(Guid) => Guid.Parse(param.Value),
            _ => param.Value
        };

        return Expression.Constant(convertedParam);
    }

    public static string GetPageUrlWithParams(IReadOnlyDictionary<string, string>? queryParams = null)
    {
        const string BASE_PATH = "/items";
        if (queryParams == null || !queryParams.Any())
        {
            return BASE_PATH;
        }

        string queryString = string.Join("&", queryParams
            .Where(kvp => !string.IsNullOrWhiteSpace(kvp.Value))
            .Select(kvp => $"{Uri.EscapeDataString(kvp.Key)}={Uri.EscapeDataString(kvp.Value)}"));

        return $"{BASE_PATH}?{queryString}";
    }

    public void RemoveQueryParamsAndNavigate(params string[] keys)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        Dictionary<string, StringValues> updatedQueryParameters = QueryHelpers.ParseQuery(currentUri.Query)
            .Where(p => !keys.Contains(p.Key)) // Exclude the keys to remove
            .ToDictionary();

        // Build the updated URL
        Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        string baseUri = uri.GetLeftPart(UriPartial.Path); // Get the base URL without the query string
        string newQueryString = QueryHelpers.AddQueryString(baseUri, updatedQueryParameters);

        // Navigate to the updated URL
        NavigationManager.NavigateTo(newQueryString);
    }

    public void RemoveQueryParamAndNavigate(string key)
    {
        RemoveQueryParamsAndNavigate(key);
    }

    public void AddOrInsertQueryParamsAndNavigate(IEnumerable<(string key, string[] values)> newQueryParams)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        Dictionary<string, StringValues> updatedQueryParameters = QueryHelpers.ParseQuery(currentUri.Query);

        foreach ((string key, string[] values) in newQueryParams)
        {
            updatedQueryParameters[key] = values;
        }

        // Build the updated URL
        Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        string baseUri = uri.GetLeftPart(UriPartial.Path); // Get the base URL without the query string
        string newQueryString = QueryHelpers.AddQueryString(baseUri, updatedQueryParameters);

        // Navigate to the updated URL
        NavigationManager.NavigateTo(newQueryString);
    }

    public void AddOrInsertQueryParamAndNavigate(string key, params string[] values)
    {
        AddOrInsertQueryParamsAndNavigate([(key, values)]);
    }

    public StringValues GetQueryParamValue(string key)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        return QueryHelpers.ParseQuery(currentUri.Query)
            .FirstOrDefault(p => p.Key == key)
            .Value
            .FirstOrDefault();
    }

    private string badgeFilterInputValue = "";
}

@{
    // get the query parameters
    Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
    // we only allow each param to be specified once, so pick the first value
    Dictionary<string, StringValues> queryParameters = QueryHelpers.ParseQuery(uri.Query)
        .Where(x => x.Value.Count > 0)
        .ToDictionary();

    WarehouseDbContext warehouseDb = WarehouseDbContextFactory.CreateDbContext();

    // parse url params which are not additional properties but "base properties" we store directly
    // as a DB column instead of as JSON
    List<PropertyInfo> basePropInfos = typeof(Item)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(FilterablePropertyAttribute)))
        .ToList();
    Dictionary<string, string> baseParams = queryParameters
        .PopWhere(param => basePropInfos.Any(prop => prop.Name == param.Key) && param.Value.Count > 0)
        .ToDictionary(x => x.Key, x => x.Value.First()!);

    // do the same not for base params, but for item state params
    List<PropertyInfo> statePropInfos = typeof(ItemState)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(FilterablePropertyAttribute)))
        .ToList();
    Dictionary<string, string> stateParams = queryParameters
        .PopWhere(param => statePropInfos.Any(prop => prop.Name == param.Key) && param.Value.Count > 0)
        .ToDictionary(x => x.Key, x => x.Value.First()!);

    // an "at" date can be passed as a URL parameter to define for what point in time the item state params should be matched
    DateTime? atParam = queryParameters
        .PopWhere(param => param.Key == "at" && param.Value.Count > 0)
        .Select(param => DateTime.Parse(param.Value.First()!))
        .Cast<DateTime?>()
        .FirstOrDefault();

    // a "showShipped=bool" param can be passed to define if items that have already been shipped at that point in time should be shown
    bool showShipped = queryParameters
        .PopWhere(param => param.Key == "showShipped" && param.Value.Count > 0)
        .Select(param => bool.Parse(param.Value.First()!))
        .FirstOrDefault();

    // a "groupby" param can be passed specifying a property the results should be grouped by
    string? groupByProperty = queryParameters
        .PopWhere(param => param.Key == "groupBy")
        .Select(param => param.Value.FirstOrDefault())
        .FirstOrDefault();

    // a "sortBy" param can be passed specifying a column/property to sort by
    string? sortByProperty = queryParameters
        .PopWhere(param => param.Key == "sortBy")
        .Select(param => param.Value.FirstOrDefault())
        .FirstOrDefault();

    // a "orderDescending" param can be passed specifying if the sort order should be descending
    bool orderDescending = queryParameters
        .PopWhere(param => param.Key == "orderDescending")
        .Select(param => bool.Parse(param.Value.FirstOrDefault()!))
        .FirstOrDefault();

    // get the column parameters. Here, we allow specifying the "column" parameter multiple times
    // to display multiple columns
    List<string> columnsToDisplay = queryParameters
        .PopWhere(x => x.Key == "col")
        .SelectMany(x => x.Value.ToList())
        .OfType<string>()
        .ToList();

    // construct the db query
    IQueryable<Item> itemsQueryable = warehouseDb.Items
        .Include(it => it.Customer);

    if (!showShipped)
    {
        itemsQueryable = atParam.HasValue
            ? itemsQueryable.Where(it => it.ItemStates.OrderByDescending(st => st.Date).First(st => st.Date <= atParam).Location != SpecialLocations.SHIPPED)
            : itemsQueryable.Where(it => it.ItemStates.OrderByDescending(st => st.Date).First().Location != SpecialLocations.SHIPPED);
    }

    // construct an expression to filter for the base item properties passed as query params
    foreach (KeyValuePair<string, string> param in baseParams)
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            GenerateTypeConvertingConstantExpression(propertyExpression, param));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(equalityExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }

    // construct an expression to filter for the item state properties passed as query params
    foreach (KeyValuePair<string, string> param in stateParams)
    {
        MemberExpression propertyExpression = Expression.Property(itemStateParameterExpression, param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            GenerateTypeConvertingConstantExpression(propertyExpression, param));
        Expression<Func<ItemState, bool>> lambda = Expression.Lambda<Func<ItemState, bool>>(
            equalityExpression,
            itemStateParameterExpression
        );

        if (atParam.HasValue)
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .Where(st => st.Date < atParam.Value)
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
        else
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
    }

    // if any AdditionalProperties query params have been specified, construct an expression to filter for those
    if (queryParameters.Count > 0)
    {
        // create a json document which contains the properties we want to filter for
        JsonObject jsonFilter = new();
        foreach (KeyValuePair<string, StringValues> queryParam in queryParameters)
        {
            if (queryParam.Value.Count == 0)
                continue;

            jsonFilter[queryParam.Key] = queryParam.Value.First();
        }
        JsonDocument jsonFilterDoc = jsonFilter.Deserialize<JsonDocument>()!;

        // call the JsonContains function with the json filter document we built
        MethodCallExpression callJsonContainsExpression = Expression.Call(
            jsonContainsMethod,
            Expression.Constant(EF.Functions),
            Expression.Property(itemParameterExpression, nameof(Item.AdditionalProperties)),
            Expression.Constant(jsonFilterDoc));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(callJsonContainsExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }

    // get the used item schemas and extract the additional properties our items could have
    IEnumerable<ItemSchema> itemSchemas = itemsQueryable
        .Select(it => it.ItemSchema)
        .Distinct();
    List<string> schemasAdditionalProperties = itemSchemas.SelectMany(sch => sch.AdditionalProperties).ToList();

    // get a list of column property names which are allowed
    List<string> allowedPropertyColumns = typeof(Item)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
        .Select(p => p.Name)
        .ToList();
    allowedPropertyColumns.AddRange(typeof(ItemState)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
        .Select(p => p.Name));
    allowedPropertyColumns.AddRange(schemasAdditionalProperties);
    
    // if no columns to display are specified, show some sane default columns
    if (columnsToDisplay.Count == 0)
    {
        columnsToDisplay = [
            nameof(Item.Id),
            nameof(Item.Customer),
            nameof(Item.ItemNumber),
            nameof(ItemState.Warehouse),
            nameof(ItemState.Location),
        ];
        columnsToDisplay.AddRange(schemasAdditionalProperties);
    }

    OrderedDictionary<string, bool> displayPropertyColumns = new();

    foreach (string columnName in columnsToDisplay)
    {
        if (allowedPropertyColumns.Contains(columnName))
            displayPropertyColumns.Add(columnName, true);
    }

    foreach (string columnName in allowedPropertyColumns)
    {
        displayPropertyColumns.TryAdd(columnName, false);
    }
}


<div>
    <span>Default Views:</span>
    @foreach (Customer customer in warehouseDb.Items.Select(it => it.Customer).Distinct().ToList())
    {
        <a class="badge rounded-pill"
           href="@GetPageUrlWithParams(new Dictionary<string, string> { ["CustomerId"] = customer.Id.ToString() })">
            Customer: @customer.Name
        </a>
    }
</div>
<div>
    <span>My Views:</span>
</div>

@code {
    private void EditParamBadge(string paramName)
    {
        badgeFilterInputValue = GetQueryParamValue(paramName).FirstOrDefault() ?? "";
        badgeEditingParamName = paramName;
    }

    private void EditParamBadgeOnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key != "Enter" || badgeEditingParamName == null)
            return;

        AddOrInsertQueryParamAndNavigate(badgeEditingParamName, badgeFilterInputValue);
        badgeEditingParamName = null;
        badgeFilterInputValue = "";
    }
}

<div>
    <span>Filter By:</span>
    @foreach (string propertyName in basePropInfos.Select(pi => pi.Name).Concat(schemasAdditionalProperties).Concat(queryParameters.Keys))
    {
        string? paramValue = baseParams.GetValueOrDefault(propertyName)
        ?? stateParams.GetValueOrDefault(propertyName)
        ?? queryParameters.GetValueOrDefault(propertyName);

        <span class="filter-badge badge rounded-pill"
              @onclick="() => EditParamBadge(propertyName)">
            <span>@propertyName</span>
            @if (paramValue != null || propertyName == badgeEditingParamName)
            {
                <span>=</span>
                if (propertyName == badgeEditingParamName)
                {
                    <InputText @bind-Value="badgeFilterInputValue"
                               @onkeyup="EditParamBadgeOnKeyDown" />
                }
                else
                {
                    <span>@paramValue</span>
                }

                <span class="btn-filter-remove material-symbols-rounded"
                      @onclick="() => { RemoveQueryParamAndNavigate(propertyName); badgeEditingParamName = null; }"
                      @onclick:stopPropagation="true">
                    close
                </span>
            }
        </span>
    }
</div>

@if (groupByProperty == null)
{
    List<Item> items = itemsQueryable
        .Include(it => it.ItemStates)
        .ThenInclude(st => st.Warehouse)
        .ToList();

    <WarehouseItemTableComponent Parent="@this"
                                 Items="@items"
                                 AtDate="atParam"
                                 PropertyColumns="displayPropertyColumns"
                                 SortByColumn="@sortByProperty"
                                 SortOrderDescending="@orderDescending">
    </WarehouseItemTableComponent>
}
else
{
    List<IGrouping<object?, Item>> itemGroups;
    if (basePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, groupByProperty);
        Expression<Func<Item, object>> lambda = Expression.Lambda<Func<Item, object>>(propertyExpression, itemParameterExpression);
        itemGroups = itemsQueryable.GroupBy(lambda).ToList();
    }
    else if (statePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, nameof(Item.ItemStates));

        // Convert ItemStates to IQueryable (EF Core needs this for translation)
        MethodCallExpression asQueryableCall = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.AsQueryable),
            [typeof(ItemState)],
            propertyExpression
        );

        // build the where call expression and call it on the "it.ItemStates" property
        Expression<Func<ItemState, bool>> dateWhereLambda = st => st.Date <= atParam.Value;
        MethodCallExpression whereCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.Where),
            [typeof(ItemState)],
            asQueryableCall,
            dateWhereLambda);

        // build the OrderByDescending call expression and chain call it
        Expression<Func<ItemState, DateTime>> orderByDescendingLambda = st => st.Date;
        MethodCallExpression orderByDescendingCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.OrderByDescending),
            new[] { typeof(ItemState), typeof(DateTime) },
            atParam != null ? whereCallExpression : asQueryableCall,
            orderByDescendingLambda);

        // build the First call expression and chain call it
        MethodCallExpression firstCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.First),
            new[] { typeof(ItemState) },
            orderByDescendingCallExpression);

        // build the property comparison expression and chain call it
        MemberExpression statePropertyExpression = Expression.Property(firstCallExpression, groupByProperty);

        Expression<Func<Item, object?>> keySelectorLambda = Expression.Lambda<Func<Item, object?>>(statePropertyExpression, itemParameterExpression);

        itemGroups = itemsQueryable
            .AsQueryable()
            .GroupBy(keySelectorLambda).ToList();
    }
    else
    {
        itemGroups = itemsQueryable
            .AsQueryable()
            .GroupBy(it => (object?)it.AdditionalProperties.RootElement.GetProperty(groupByProperty).GetString())
            .ToList();
    }

    <WarehouseGroupedItemTableComponent ItemGroups="@itemGroups" GroupByPropertyName="@groupByProperty"></WarehouseGroupedItemTableComponent>
}