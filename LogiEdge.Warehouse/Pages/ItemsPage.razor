@page "/items"
@using LogiEdge.Shared.Utility
@using System.Linq.Expressions
@using System.Reflection
@using System.Text.Json
@using System.Text.Json.Nodes
@using LogiEdge.CustomerService.Data
@using LogiEdge.Shared
@using LogiEdge.Shared.Attributes
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Persistence
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.EntityFrameworkCore
@using LogiEdge.Warehouse.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Primitives
@using LogiEdge.Warehouse.Components.PropertyFilterBadge
@inject IDbContextFactory<WarehouseDbContext> WarehouseDbContextFactory
@inject NavigationManager NavigationManager

<h3>Items by Property</h3>

@code {
    protected override void OnInitialized()
    {
        base.OnInitialized();

        // necessary to refresh the page if the query parameters change
        NavigationManager.LocationChanged += (sender, args) => StateHasChanged();
    }

    private string? badgeEditingParamName = null;

    private static readonly ParameterExpression itemParameterExpression = Expression.Parameter(typeof(Item), "it");
    private static readonly MethodInfo jsonContainsMethod = typeof(NpgsqlJsonDbFunctionsExtensions)
        .GetMethod(nameof(NpgsqlJsonDbFunctionsExtensions.JsonContains), [typeof(DbFunctions), typeof(JsonDocument), typeof(JsonDocument)])!;
    private static readonly ParameterExpression itemStateParameterExpression = Expression.Parameter(typeof(ItemState), "st");

    public static string GetPageUrlWithParams(IReadOnlyDictionary<string, string>? queryParams = null)
    {
        const string BASE_PATH = "/items";
        if (queryParams == null || !queryParams.Any())
        {
            return BASE_PATH;
        }

        string queryString = string.Join("&", queryParams
            .Where(kvp => !string.IsNullOrWhiteSpace(kvp.Value))
            .Select(kvp => $"{Uri.EscapeDataString(kvp.Key)}={Uri.EscapeDataString(kvp.Value)}"));

        return $"{BASE_PATH}?{queryString}";
    }

    public void RemoveQueryParamsAndNavigate(params string[] keys)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        Dictionary<string, StringValues> updatedQueryParameters = QueryHelpers.ParseQuery(currentUri.Query)
            .Where(p => !keys.Contains(p.Key)) // Exclude the keys to remove
            .ToDictionary();

        atParam = null;

        // Build the updated URL
        Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        string baseUri = uri.GetLeftPart(UriPartial.Path); // Get the base URL without the query string
        string newQueryString = QueryHelpers.AddQueryString(baseUri, updatedQueryParameters);

        // Navigate to the updated URL
        NavigationManager.NavigateTo(newQueryString);
    }

    public void RemoveQueryParamAndNavigate(string key)
    {
        RemoveQueryParamsAndNavigate(key);
    }

    public void AddOrUpdateQueryParamsAndNavigate(IEnumerable<(string key, string[] values)> newQueryParams)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        Dictionary<string, StringValues> updatedQueryParameters = QueryHelpers.ParseQuery(currentUri.Query);

        foreach ((string key, string[] values) in newQueryParams)
        {
            updatedQueryParameters[key] = values;
        }

        atParam = null;

        // Build the updated URL
        Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        string baseUri = uri.GetLeftPart(UriPartial.Path); // Get the base URL without the query string
        string newQueryString = QueryHelpers.AddQueryString(baseUri, updatedQueryParameters);

        // Navigate to the updated URL
        NavigationManager.NavigateTo(newQueryString);
    }

    public void AddOrUpdateQueryParamAndNavigate(string key, params string[] values)
    {
        AddOrUpdateQueryParamsAndNavigate([(key, values)]);
    }

    public StringValues GetQueryParamValue(string key)
    {
        // Create a copy of the current query parameters
        Uri currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        return QueryHelpers.ParseQuery(currentUri.Query)
            .FirstOrDefault(p => p.Key == key)
            .Value
            .FirstOrDefault();
    }

    private DateTime? atParam { get; set; } = null;

}

@{
    // get the query parameters
    Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
    // we only allow each param to be specified once, so pick the first value
    Dictionary<string, StringValues> queryParameters = QueryHelpers.ParseQuery(uri.Query)
        .Where(x => x.Value.Count > 0)
        .ToDictionary();

    WarehouseDbContext warehouseDb = WarehouseDbContextFactory.CreateDbContext();

    // parse url params which are not additional properties but "base properties" we store directly
    // as a DB column instead of as JSON
    List<PropertyInfo> basePropInfos = typeof(Item)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(QueryFilterablePropertyAttribute)))
        .ToList();
    Dictionary<string, object> baseParams = queryParameters
        .PopWhere(param => basePropInfos.Any(prop => prop.Name == param.Key) && param.Value.Count > 0)
        .ToDictionary<KeyValuePair<string, StringValues>, string, object>(
            x => x.Key,
            x =>
        {
            string stringValue = x.Value.First()!;

            PropertyInfo propInfo = basePropInfos.FirstOrDefault(prop => prop.Name == x.Key)
                                    ?? throw new Exception("Could not find property with name " + x.Key);

            Type propertyType;

            if (propInfo.GetCustomAttribute<QueryFilterablePropertyAttribute>() is { CompareQueryParamWith: not null } attr)
            {
                PropertyInfo comparePropInfo = typeof(Item).GetProperty(attr.CompareQueryParamWith)
                                               ?? throw new Exception(
                                                   "Property " + attr.CompareQueryParamWith + ", referenced by [QueryFilterableProperty] attribute on property "
                                                   + propInfo.Name + ", could not be found on type " + propInfo.DeclaringType?.Name);

                propertyType = comparePropInfo.PropertyType;
            }
            else
            {
                propertyType = propInfo.PropertyType;
            }

            return propertyType switch
            {
                { } t when t == typeof(int) => int.Parse(stringValue),
                { } t when t == typeof(decimal) => decimal.Parse(stringValue),
                { } t when t == typeof(DateTime) => DateTime.SpecifyKind(DateTime.Parse(stringValue), DateTimeKind.Utc),
                { } t when t == typeof(Guid) => Guid.Parse(stringValue),
                _ => stringValue
            };
        });

    // do the same not for base params, but for item state params
    List<PropertyInfo> statePropInfos = typeof(ItemState)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(QueryFilterablePropertyAttribute)))
        .ToList();
    Dictionary<string, object> stateParams = queryParameters
        .PopWhere(param => statePropInfos.Any(prop => prop.Name == param.Key) && param.Value.Count > 0)
        .ToDictionary<KeyValuePair<string, StringValues>, string, object>(
            x => x.Key,
            x =>
            {
                string stringValue = x.Value.First()!;

                PropertyInfo propInfo = statePropInfos.FirstOrDefault(prop => prop.Name == x.Key)
                                        ?? throw new Exception("Could not find property with name " + x.Key);

                Type propertyType;

                if (propInfo.GetCustomAttribute<QueryFilterablePropertyAttribute>() is { CompareQueryParamWith: not null } attr)
                {
                    PropertyInfo comparePropInfo = typeof(ItemState).GetProperty(attr.CompareQueryParamWith)
                                                   ?? throw new Exception(
                                                       "Property " + attr.CompareQueryParamWith + ", referenced by [QueryFilterableProperty] attribute on property "
                                                       + propInfo.Name + ", could not be found on type " + propInfo.DeclaringType?.Name);

                    propertyType = comparePropInfo.PropertyType;
                }
                else
                {
                    propertyType = propInfo.PropertyType;
                }

                return propertyType switch
                {
                    { } t when t == typeof(int) => int.Parse(stringValue),
                    { } t when t == typeof(decimal) => decimal.Parse(stringValue),
                    { } t when t == typeof(DateTime) => DateTime.SpecifyKind(DateTime.Parse(stringValue), DateTimeKind.Utc),
                    { } t when t == typeof(Guid) => Guid.Parse(stringValue),
                    _ => stringValue
                };
            });

    // an "at" date can be passed as a URL parameter to define for what point in time the item state params should be matched
    atParam = queryParameters
        .PopWhere(param => param.Key == "at" && param.Value.Count > 0)
        .Select(param => DateTime.SpecifyKind(DateTime.Parse(param.Value.First()!), DateTimeKind.Utc))
        .Cast<DateTime?>()
        .FirstOrDefault();

    // a "showShipped=bool" param can be passed to define if items that have already been shipped at that point in time should be shown
    bool showShipped = queryParameters
        .PopWhere(param => param.Key == "showShipped" && param.Value.Count > 0)
        .Select(param => bool.Parse(param.Value.First()!))
        .FirstOrDefault();

    // a "groupby" param can be passed specifying a property the results should be grouped by
    string? groupByProperty = queryParameters
        .PopWhere(param => param.Key == "groupBy")
        .Select(param => param.Value.FirstOrDefault())
        .FirstOrDefault();

    // a "sortBy" param can be passed specifying a column/property to sort by
    string? sortByProperty = queryParameters
        .PopWhere(param => param.Key == "sortBy")
        .Select(param => param.Value.FirstOrDefault())
        .FirstOrDefault();

    // a "orderDescending" param can be passed specifying if the sort order should be descending
    bool orderDescending = queryParameters
        .PopWhere(param => param.Key == "orderDescending")
        .Select(param => bool.Parse(param.Value.FirstOrDefault()!))
        .FirstOrDefault();

    // get the column parameters. Here, we allow specifying the "column" parameter multiple times
    // to display multiple columns
    List<string> columnsToDisplay = queryParameters
        .PopWhere(x => x.Key == "col")
        .SelectMany(x => x.Value.ToList())
        .OfType<string>()
        .ToList();

    // construct the db query
    IQueryable<Item> itemsQueryable = warehouseDb.Items
        .Include(it => it.Customer);

    if (!showShipped)
    {
        itemsQueryable = atParam.HasValue
            ? itemsQueryable.Where(it => it.ItemStates.OrderByDescending(st => st.Date).First(st => st.Date <= atParam).Location != SpecialLocations.SHIPPED)
            : itemsQueryable.Where(it => it.ItemStates.OrderByDescending(st => st.Date).First().Location != SpecialLocations.SHIPPED);
    }

    // construct an expression to filter for the base item properties passed as query params
    foreach (KeyValuePair<string, object> param in baseParams)
    {
        string? foreignComparisonKey = basePropInfos
            .FirstOrDefault(pi => pi.Name == param.Key)?
            .GetCustomAttribute<QueryFilterablePropertyAttribute>()?
            .CompareQueryParamWith;

        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, foreignComparisonKey ?? param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            Expression.Constant(param.Value));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(equalityExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }

    // construct an expression to filter for the item state properties passed as query params
    foreach (KeyValuePair<string, object> param in stateParams)
    {
        string? foreignComparisonKey = statePropInfos
            .FirstOrDefault(pi => pi.Name == param.Key)?
            .GetCustomAttribute<QueryFilterablePropertyAttribute>()?
            .CompareQueryParamWith;

        MemberExpression propertyExpression = Expression.Property(itemStateParameterExpression, foreignComparisonKey ?? param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            Expression.Constant(param.Value));
        Expression<Func<ItemState, bool>> lambda = Expression.Lambda<Func<ItemState, bool>>(
            equalityExpression,
            itemStateParameterExpression
        );

        if (atParam.HasValue)
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .Where(st => st.Date < atParam.Value)
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
        else
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
    }

    // if any AdditionalProperties query params have been specified, construct an expression to filter for those
    if (queryParameters.Count > 0)
    {
        // create a json document which contains the properties we want to filter for
        JsonObject jsonFilter = new();
        foreach (KeyValuePair<string, StringValues> queryParam in queryParameters)
        {
            if (queryParam.Value.Count == 0)
                continue;

            jsonFilter[queryParam.Key] = queryParam.Value.First();
        }
        JsonDocument jsonFilterDoc = jsonFilter.Deserialize<JsonDocument>()!;

        // call the JsonContains function with the json filter document we built
        MethodCallExpression callJsonContainsExpression = Expression.Call(
            jsonContainsMethod,
            Expression.Constant(EF.Functions),
            Expression.Property(itemParameterExpression, nameof(Item.AdditionalProperties)),
            Expression.Constant(jsonFilterDoc));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(callJsonContainsExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }

    // get the used item schemas and extract the additional properties our items could have
    IEnumerable<ItemSchema> itemSchemas = itemsQueryable
        .Select(it => it.ItemSchema)
        .Distinct();
    List<string> schemasAdditionalProperties = itemSchemas.SelectMany(sch => sch.AdditionalProperties).ToList();

    // get a list of column property names which are allowed
    List<string> allowedPropertyColumns = typeof(Item)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
        .Select(p => p.Name)
        .ToList();
    allowedPropertyColumns.AddRange(typeof(ItemState)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
        .Select(p => p.Name));
    allowedPropertyColumns.AddRange(schemasAdditionalProperties);

    // if no columns to display are specified, show some sane default columns
    if (columnsToDisplay.Count == 0)
    {
        columnsToDisplay = [
            nameof(Item.Id),
    nameof(Item.Customer),
    nameof(Item.ItemNumber),
    nameof(ItemState.Warehouse),
    nameof(ItemState.Location),
    nameof(Item.EntryDate)
        ];
        columnsToDisplay.AddRange(schemasAdditionalProperties);
    }

    OrderedDictionary<string, bool> displayPropertyColumns = new();

    foreach (string columnName in columnsToDisplay)
    {
        if (allowedPropertyColumns.Contains(columnName))
            displayPropertyColumns.Add(columnName, true);
    }

    foreach (string columnName in allowedPropertyColumns)
    {
        displayPropertyColumns.TryAdd(columnName, false);
    }
}

<div>
    <span>Default Views:</span>
    @foreach (Customer customer in warehouseDb.Items.Select(it => it.Customer).Distinct().ToList())
    {
        <a class="badge rounded-pill"
           href="@GetPageUrlWithParams(new Dictionary<string, string> { ["Customer"] = customer.Id.ToString() })">
            Customer: @customer.Name
        </a>
    }
</div>
<div>
    <span>My Views:</span>
</div>

@code {
    private void EditParamBadge(string paramName)
    {
        badgeEditingParamName = paramName;
    }

    private void EditPropertyFilterBadgeFinished(string propertyName, string? newValue)
    {
        if (newValue != null)
            AddOrUpdateQueryParamAndNavigate(propertyName, newValue.ToString());
        else
            RemoveQueryParamAndNavigate(propertyName);

        if(badgeEditingParamName == propertyName)
            badgeEditingParamName = null;
    }
}

<div>
    <span>Filter By:</span>
    @foreach (string propertyName in basePropInfos.Select(pi => pi.Name)
    .Concat(statePropInfos.Select(pi => pi.Name))
    .Concat(schemasAdditionalProperties)
    .Concat(queryParameters.Keys)
    .Distinct())
    {
        object? paramValue = baseParams.GetValueOrDefault(propertyName)
        ?? stateParams.GetValueOrDefault(propertyName);

        if (paramValue == null)
        {
            if (queryParameters.TryGetValue(propertyName, out StringValues stringValues))
                paramValue = stringValues.First();
        }

        string? propertyType = basePropInfos.FirstOrDefault(pi => pi.Name == propertyName)?.PropertyType.Name
        ?? statePropInfos.FirstOrDefault(pi => pi.Name == propertyName)?.PropertyType.Name;

        if (propertyType == null)
        {
            ItemSchema? schema = itemSchemas.FirstOrDefault(sch => sch.AdditionalProperties.Contains(propertyName));

            if (schema != null)
            {
                int index = schema.AdditionalProperties.IndexOf(propertyName);
                propertyType = schema.AdditionalPropertiesTypes[index];
            }
        }

        if (propertyType == null)
            throw new Exception("Could not determine Type of property " + propertyName);

        bool isEditing = propertyName == badgeEditingParamName;

        switch (propertyType)
        {
            case nameof(DateTime):
                <DateTimePropertyFilterBadge @key="propertyName"
                                             PropertyName="@propertyName"
                                             PropertyValue="@(((DateTime?)paramValue)?.ToLocalTime())"
                                             IsEditing="@isEditing"
                                             OnEditingRequested="sender => badgeEditingParamName = sender.PropertyName"
                                             OnRemoveFilter="sender => EditPropertyFilterBadgeFinished(sender.PropertyName, null)"
                                             OnEditingFinished='newValue => EditPropertyFilterBadgeFinished(propertyName, newValue?.ToUniversalTime().ToString("o"))' />
                break;
            case nameof(WarehouseService.Data.Warehouse):
                List<WarehouseService.Data.Warehouse> allWarehouses = warehouseDb.Warehouses.ToList();
                WarehouseService.Data.Warehouse? selectedWarehouse = allWarehouses.FirstOrDefault(w => w.Id == (Guid?)paramValue);

                <DropdownPropertyFilterBadge @key="propertyName"
                                             PropertyName="@propertyName"
                                             PropertyValue="@selectedWarehouse?.Id.ToString()"
                                             TItem="string"
                                             Options="@(new List<string>() {Guid.Empty.ToString()}.Concat(allWarehouses.Select(x => x.Id.ToString())).ToList())"
                                             DisplayTextFunc="id => allWarehouses.FirstOrDefault(wh => wh.Id == Guid.Parse(id))?.Name"
                                             IsEditing="@isEditing"
                                             OnEditingRequested="sender => badgeEditingParamName = sender.PropertyName"
                                             OnRemoveFilter="sender => EditPropertyFilterBadgeFinished(sender.PropertyName, null)"
                                             OnEditingFinished="newValue => EditPropertyFilterBadgeFinished(propertyName, newValue != Guid.Empty.ToString() ? newValue : null)" />
                break;
            case nameof(Customer):
                List<Customer> allCustomers = warehouseDb.Items.Select(it => it.Customer).Distinct().ToList();
                Customer? selectedCustomer = allCustomers.FirstOrDefault(c => c.Id == (Guid?)paramValue);

                <DropdownPropertyFilterBadge @key="propertyName"
                                             PropertyName="@propertyName"
                                             PropertyValue="@selectedCustomer?.Id.ToString()"
                                             TItem="string"
                                             Options="@(new List<string>() {Guid.Empty.ToString()}.Concat(allCustomers.Select(x => x.Id.ToString())).ToList())"
                                             DisplayTextFunc="id => allCustomers.FirstOrDefault(cu => cu.Id == Guid.Parse(id))?.Name"
                                             IsEditing="@isEditing"
                                             OnEditingRequested="sender => badgeEditingParamName = sender.PropertyName"
                                             OnRemoveFilter="sender => EditPropertyFilterBadgeFinished(sender.PropertyName, null)"
                                             OnEditingFinished="newValue => EditPropertyFilterBadgeFinished(propertyName, newValue != Guid.Empty.ToString() ? newValue : null)" />
                break;
            case nameof(String):
                <StringPropertyFilterBadge @key="propertyName"
                                           PropertyName="@propertyName"
                                           PropertyValue="@((string?)paramValue)"
                                           IsEditing="@isEditing"
                                           OnEditingRequested="sender => badgeEditingParamName = sender.PropertyName"
                                           OnRemoveFilter="sender => EditPropertyFilterBadgeFinished(sender.PropertyName, null)"
                                           OnEditingFinished="newValue => EditPropertyFilterBadgeFinished(propertyName, newValue)" />
                break;
        }
    }
</div>

@{
    DateTime inputAtParam = atParam ?? DateTime.UtcNow.ToLocalTime();
}

<div>
    <span>Show Warehouse at Point in Time:</span>
    <InputDate Type="InputDateType.DateTimeLocal"
               Value="inputAtParam"
               ValueExpression="() => inputAtParam"
               ValueChanged='(DateTime dt) => { DateTime? newDate = dt.SpecifyKind(DateTimeKind.Local).ToUniversalTime(); AddOrUpdateQueryParamAndNavigate("at", newDate.Value.ToString("o")); }' />
    <button class="btn btn-secondary btn-sm"
            @onclick='() => RemoveQueryParamAndNavigate("at")'>
        Now
    </button>
</div>

@if (groupByProperty == null)
{
    List<Item> items = itemsQueryable
        .Include(it => it.ItemStates)
        .ThenInclude(st => st.Warehouse)
        .ToList();

    <WarehouseItemTableComponent Parent="@this"
                                 Items="@items"
                                 AtDate="@atParam"
                                 PropertyColumns="@displayPropertyColumns"
                                 SortByColumn="@sortByProperty"
                                 SortOrderDescending="@orderDescending" />
}
else
{
    List<IGrouping<object?, Item>> itemGroups;
    if (basePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, groupByProperty);
        Expression<Func<Item, object>> lambda = Expression.Lambda<Func<Item, object>>(propertyExpression, itemParameterExpression);
        itemGroups = itemsQueryable.GroupBy(lambda).ToList();
    }
    else if (statePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, nameof(Item.ItemStates));

        // Convert ItemStates to IQueryable (EF Core needs this for translation)
        MethodCallExpression asQueryableCall = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.AsQueryable),
            [typeof(ItemState)],
            propertyExpression
        );

        // build the where call expression and call it on the "it.ItemStates" property
        Expression<Func<ItemState, bool>> dateWhereLambda = st => st.Date <= atParam.Value;
        MethodCallExpression whereCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.Where),
            [typeof(ItemState)],
            asQueryableCall,
            dateWhereLambda);

        // build the OrderByDescending call expression and chain call it
        Expression<Func<ItemState, DateTime>> orderByDescendingLambda = st => st.Date;
        MethodCallExpression orderByDescendingCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.OrderByDescending),
            new[] { typeof(ItemState), typeof(DateTime) },
            atParam != null ? whereCallExpression : asQueryableCall,
            orderByDescendingLambda);

        // build the First call expression and chain call it
        MethodCallExpression firstCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.First),
            new[] { typeof(ItemState) },
            orderByDescendingCallExpression);

        // build the property comparison expression and chain call it
        MemberExpression statePropertyExpression = Expression.Property(firstCallExpression, groupByProperty);

        Expression<Func<Item, object?>> keySelectorLambda = Expression.Lambda<Func<Item, object?>>(statePropertyExpression, itemParameterExpression);

        itemGroups = itemsQueryable
            .AsQueryable()
            .GroupBy(keySelectorLambda).ToList();
    }
    else
    {
        itemGroups = itemsQueryable
            .AsQueryable()
            .GroupBy(it => (object?)it.AdditionalProperties.RootElement.GetProperty(groupByProperty).GetString())
            .ToList();
    }

    <WarehouseGroupedItemTableComponent ItemGroups="@itemGroups" GroupByPropertyName="@groupByProperty" />
}