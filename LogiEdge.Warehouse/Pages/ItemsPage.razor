@page "/items"
@using System.Linq.Expressions
@using System.Reflection
@using System.Text.Json
@using System.Text.Json.Nodes
@using LogiEdge.Shared
@using LogiEdge.Shared.Utility
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Persistence
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.EntityFrameworkCore
@using LogiEdge.Warehouse.Components
@inject IDbContextFactory<WarehouseDbContext> WarehouseDbContextFactory
@inject NavigationManager NavigationManager

<h3>Items by Property</h3>

@code {
    protected override void OnInitialized()
    {
        base.OnInitialized();

        NavigationManager.LocationChanged += (sender, args) => StateHasChanged();
    }

    private static readonly ParameterExpression itemParameterExpression = Expression.Parameter(typeof(Item), "it");
    private static readonly MethodInfo jsonContainsMethod = typeof(NpgsqlJsonDbFunctionsExtensions)
        .GetMethod(nameof(NpgsqlJsonDbFunctionsExtensions.JsonContains), [typeof(DbFunctions), typeof(JsonDocument), typeof(JsonDocument)])!;
    private static readonly ParameterExpression itemStateParameterExpression = Expression.Parameter(typeof(ItemState), "st");

    private static Expression GenerateTypeConvertingConstantExpression(MemberExpression memberExpression, KeyValuePair<string, string> param)
    {
        object convertedParam = memberExpression.Type switch
        {
            { } t when t == typeof(int) => int.Parse(param.Value),
            { } t when t == typeof(decimal) => decimal.Parse(param.Value),
            { } t when t == typeof(DateTime) => DateTime.Parse(param.Value),
            { } t when t == typeof(Guid) => Guid.Parse(param.Value),
            _ => param.Value
        };

        return Expression.Constant(convertedParam);
    }
}

@{
    // get the query parameters
    Uri uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
    // we only allow each param to be specified once, so pick the first value
    Dictionary<string, string> queryParameters = QueryHelpers.ParseQuery(uri.Query)
        .Where(x => x.Value.Count > 0)
        .ToDictionary(x => x.Key, x => x.Value.First())!;

    WarehouseDbContext warehouseDb = WarehouseDbContextFactory.CreateDbContext();

    // parse url params which are not additional properties but "base properties" we store directly
    // as a DB column instead of as JSON
    IEnumerable<PropertyInfo> basePropInfos = typeof(Item)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(FilterablePropertyAttribute)));
    Dictionary<string, string> baseParams = queryParameters
        .PopWhere(param => basePropInfos.Any(prop => prop.Name == param.Key))
        .ToDictionary();

    // do the same not for base params, but for item state params
    IEnumerable<PropertyInfo> statePropInfos = typeof(ItemState)
        .GetProperties()
        .Where(p => Attribute.IsDefined(p, typeof(FilterablePropertyAttribute)));
    Dictionary<string, string> stateParams = queryParameters
        .PopWhere(param => statePropInfos.Any(prop => prop.Name == param.Key))
        .ToDictionary();

    // an "at" date can be passed as a URL parameter to define for what point in time the item state params should be matched
    DateTime? atParam = queryParameters
        .PopWhere(param => param.Key == "at")
        .Select(param => DateTime.Parse(param.Value))
        .Cast<DateTime?>()
        .FirstOrDefault();

    // a "groupby" param can be passed specifying a property the results should be grouped by
    string? groupByProperty = queryParameters
        .PopWhere(param => param.Key == "groupBy")
        .Select(param => param.Value)
        .FirstOrDefault();

    IQueryable<Item> itemsQueryable = warehouseDb.Items;

    // construct an expression to filter for the base item properties passed as query params
    foreach (KeyValuePair<string, string> param in baseParams)
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            GenerateTypeConvertingConstantExpression(propertyExpression, param));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(equalityExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }

    // construct an expression to filter for the item state properties passed as query params
    foreach (KeyValuePair<string, string> param in stateParams)
    {
        MemberExpression propertyExpression = Expression.Property(itemStateParameterExpression, param.Key);
        BinaryExpression equalityExpression = Expression.Equal(
            propertyExpression,
            GenerateTypeConvertingConstantExpression(propertyExpression, param));
        Expression<Func<ItemState, bool>> lambda = Expression.Lambda<Func<ItemState, bool>>(
            equalityExpression,
            itemStateParameterExpression
        );

        if (atParam.HasValue)
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .Where(st => st.Date < atParam.Value)
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
        else
        {
            itemsQueryable = itemsQueryable.Where(it => it.ItemStates
                .AsQueryable()
                .OrderByDescending(st => st.Date)
                .Take(1)
                .Where(lambda)
                .Any());
        }
    }

    // if any AdditionalProperties query params have been specified, construct an expression to filter for those
    if (queryParameters.Count > 0)
    {
        // create a json document which contains the properties we want to filter for
        JsonObject jsonFilter = new();
        foreach (KeyValuePair<string, string> queryParam in queryParameters)
        {
            jsonFilter[queryParam.Key] = queryParam.Value;
        }
        JsonDocument jsonFilterDoc = jsonFilter.Deserialize<JsonDocument>()!;

        // call the JsonContains function with the json filter document we built
        MethodCallExpression callJsonContainsExpression = Expression.Call(
            jsonContainsMethod,
            Expression.Constant(EF.Functions),
            Expression.Property(itemParameterExpression, nameof(Item.AdditionalProperties)),
            Expression.Constant(jsonFilterDoc));
        Expression<Func<Item, bool>> lambda = Expression.Lambda<Func<Item, bool>>(callJsonContainsExpression, itemParameterExpression);
        itemsQueryable = itemsQueryable.Where(lambda);
    }


}

@if (groupByProperty == null)
{
    List<Item> items = itemsQueryable.Include(it => it.ItemStates).ToList();
    <WarehouseItemTableComponent Items="@items"></WarehouseItemTableComponent>
}
else
{
    List<IGrouping<object, Item>> itemGroups;
    if (basePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, groupByProperty);
        Expression<Func<Item, object>> lambda = Expression.Lambda<Func<Item, object>>(propertyExpression, itemParameterExpression);
        itemGroups = itemsQueryable.GroupBy(lambda).ToList();
    }
    else if (statePropInfos.Any(pi => pi.Name == groupByProperty))
    {
        MemberExpression propertyExpression = Expression.Property(itemParameterExpression, nameof(Item.ItemStates));

        // Convert ItemStates to IQueryable (EF Core needs this for translation)
        MethodCallExpression asQueryableCall = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.AsQueryable),
            [typeof(ItemState)],
            propertyExpression
        );

        // build the where call expression and call it on the "it.ItemStates" property
        Expression<Func<ItemState, bool>> dateWhereLambda = st => st.Date < atParam.Value;
        MethodCallExpression whereCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.Where),
            [typeof(ItemState)],
            asQueryableCall,
            dateWhereLambda);

        // build the OrderByDescending call expression and chain call it
        Expression<Func<ItemState, DateTime>> orderByDescendingLambda = st => st.Date;
        MethodCallExpression orderByDescendingCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.OrderByDescending),
            new[] { typeof(ItemState), typeof(DateTime) },
            atParam != null ? whereCallExpression : asQueryableCall,
            orderByDescendingLambda);

        // build the First call expression and chain call it
        MethodCallExpression firstCallExpression = Expression.Call(
            typeof(Queryable),
            nameof(Queryable.First),
            new[] { typeof(ItemState) },
            orderByDescendingCallExpression);

        // build the property comparison expression and chain call it
        MemberExpression statePropertyExpression = Expression.Property(firstCallExpression, groupByProperty);

        Expression<Func<Item, object>> keySelectorLambda = Expression.Lambda<Func<Item, object>>(statePropertyExpression, itemParameterExpression);

        itemGroups = itemsQueryable
            .AsQueryable()
            .GroupBy(keySelectorLambda).ToList();
    }
    else
    {
        itemGroups = null;
        // TODO
    }

    <WarehouseGroupedItemTableComponent ItemGroups="@itemGroups" GroupByPropertyName="@groupByProperty"></WarehouseGroupedItemTableComponent>
}