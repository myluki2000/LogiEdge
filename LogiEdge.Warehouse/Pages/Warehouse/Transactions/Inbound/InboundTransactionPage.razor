@page "/warehouse/transactions/inbound/{TransactionId:guid}"
@using System.ComponentModel.DataAnnotations
@using System.Reflection
@using LogiEdge.BaseService.Data
@using LogiEdge.BaseService.Services
@using LogiEdge.Shared.Attributes
@using LogiEdge.Warehouse.Components
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Data.Transactions
@using LogiEdge.WarehouseService.Persistence
@using LogiEdge.WebUI.Shared.Components
@using Microsoft.EntityFrameworkCore
@using System.Text.Json
@using System.Text.Json.Nodes
@using LogiEdge.CustomerService.Data
@using Microsoft.AspNetCore.Components.Forms
@using LogiEdge.Warehouse.Components.PropertyValueInput
@implements IAsyncDisposable
@inject IDbContextFactory<WarehouseDbContext> WarehouseContextFactory
@inject FileAttachmentService FileAttachmentService

@code {
    /// <summary>
    /// The ID of the transaction this page will show
    /// </summary>
    [Parameter]
    public Guid TransactionId { get; set; }
    /// <summary>
    /// During execution of <see cref="SetParametersAsync(ParameterView)"/>, keeps
    /// track of the ID of the previou transaction this page displayed. Afterward,
    /// oldTransactionId and <see cref="TransactionId"/> will be identical.
    ///
    /// This field is necessary for when the <see cref="TransactionId"/> is changed
    /// so the <see cref="SetParametersAsync(ParameterView)"/> can save the modified
    /// data of the previous transaction.
    /// </summary>
    private Guid? oldTransactionId = null;

    private Customer? selectedCustomerToAdd = null;
    private Guid selectedItemSchemaToAdd = Guid.Empty;

    private List<(Customer customer, ItemSchema itemSchema)> customerItemSchemasToShow = [];

    private async Task OnAttachmentsUploaded(List<FileAttachment> newAttachments)
    {
        await using WarehouseDbContext ctx = await WarehouseContextFactory.CreateDbContextAsync();

        InboundTransaction? transaction = ctx.InboundTransactions
            .FirstOrDefault(t => t.Id == TransactionId);

        if (transaction == null)
            return;

        foreach (FileAttachment attachment in newAttachments)
        {
            FileAttachment entity = await FileAttachmentService.CreateAttachmentAsync(attachment);
            transaction.AttachmentIds.Add(entity.Id);
        }

        await ctx.SaveChangesAsync();
    }

    public async ValueTask DisposeAsync()
    {
        // TODO: Check if saving the page's data via the dispose method actually works reliably
        await SaveTransactionItemDraftData();
    }

    private async Task OnAttachmentRemoved(Guid attachmentId)
    {
        await using WarehouseDbContext ctx = await WarehouseContextFactory.CreateDbContextAsync();
        InboundTransaction? transaction = ctx.InboundTransactions
            .FirstOrDefault(t => t.Id == TransactionId);
        transaction?.AttachmentIds.Remove(attachmentId);
        await FileAttachmentService.DeleteAttachmentAsync(attachmentId);
        await ctx.SaveChangesAsync();
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        TransactionId = parameters.GetValueOrDefault<Guid>("TransactionId");
        if (oldTransactionId != null)
        {
            // if we navigate straight from one transaction to another (so this blazor component
            // isn't destroyed but instead just the TransactionId parameter updated), we first need
            // to save the old transaction's data
            await SaveTransactionItemDraftData();
        }

        await using WarehouseDbContext ctx = await WarehouseContextFactory.CreateDbContextAsync();

        InboundTransaction? transaction = ctx.InboundTransactions
            .Include(tr => tr.NewItemStates)
            .FirstOrDefault(t => t.Id == TransactionId);

        if (transaction != null)
        {
            customerItemSchemasToShow = transaction.State switch
            {
                TransactionState.DRAFT => transaction.DraftItems.Select(it => (it.Customer, it.ItemSchema)).Distinct().ToList(),
                TransactionState.BOOKED => transaction.AffectedItems.Select(it => (it.Customer, it.ItemSchema)).Distinct().ToList(),
                _ => throw new Exception("Unexpected transaction state: " + transaction.State)
            };

            oldTransactionId = TransactionId;
        }

        await base.SetParametersAsync(parameters);
    }

    private async Task SaveTransactionItemDraftData()
    {
        /*await using WarehouseDbContext ctx = await WarehouseContextFactory.CreateDbContextAsync();
        InboundTransaction? transaction = await ctx.InboundTransactions
        .FirstOrDefaultAsync(t => t.Id == oldTransactionId);

        if (transaction == null)
            return;

        //transaction.DraftItems = draftItems.Deserialize<JsonElement>();

        await ctx.SaveChangesAsync();*/
    }


    private void BtnAddSchemaOnClick()
    {
        if (selectedCustomerToAdd == null)
            throw new Exception("No customer selected to add item schema for.");

        using WarehouseDbContext ctx = WarehouseContextFactory.CreateDbContext();
        ItemSchema? schema = ctx.ItemSchemas.FirstOrDefault(s => s.Id == selectedItemSchemaToAdd);
        if (schema == null)
        {
            throw new Exception("Could not find item schema with ID " + selectedItemSchemaToAdd);
        }
        customerItemSchemasToShow.Add((selectedCustomerToAdd, schema));
    }

    private List<(string propertyName, Type propertyType)> GetItemPropertyColumns(ItemSchema schema)
    {
        List<(string propertyName, Type propertyType)> propertyColumns = typeof(Item)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)) &&
                        !Attribute.IsDefined(p, typeof(KeyAttribute)))
            .Select(p => (p.Name, p.PropertyType))
            .ToList();
        propertyColumns.AddRange(typeof(ItemState)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)) &&
                        !Attribute.IsDefined(p, typeof(KeyAttribute)))
            .Select(p => (p.Name, p.PropertyType)));
        propertyColumns.AddRange(schema.AdditionalProperties.Select((x, i) => (x.Name, x.Type.ToType())));

        return propertyColumns;
    }

    private List<(string propertyName, Type propertyType)> GetDraftItemPropertyColumns(ItemSchema schema)
    {
        List<(string propertyName, Type propertyType)> propertyColumns = typeof(InboundDraftItem)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)) &&
                        !Attribute.IsDefined(p, typeof(KeyAttribute)))
            .Select(p => (p.Name, p.PropertyType))
            .ToList();
        propertyColumns.AddRange(schema.AdditionalProperties.Select((x, i) => (x.Name, x.Type.ToType())));

        return propertyColumns;
    }
}
@{
    using WarehouseDbContext ctx = WarehouseContextFactory.CreateDbContext();
    InboundTransaction? transaction = ctx.InboundTransactions
        .Include(t => t.DraftItems)
        .Include(t => t.NewItemStates)
        .ThenInclude(st => st.Item)
        .FirstOrDefault(t => t.Id == TransactionId);

    if (transaction == null)
    {
        <p>Could not find transaction with ID @TransactionId</p>
        return;
    }

    List<FileAttachment> attachments = FileAttachmentService.GetAttachments(transaction.AttachmentIds);

    List<ItemSchema> itemSchemas = ctx.ItemSchemas
        .Include(sch => sch.Customers)
        .ToList();
}

<h3>InboundTransactionPage</h3>

<button>Generate Document</button>

<span>Date: @transaction.Date</span>

@foreach ((Customer customer, ItemSchema schema) in customerItemSchemasToShow)
{
    <h4>Items for @customer.Name - @schema.Name</h4>

    if (transaction.State == TransactionState.BOOKED)
    {
        <span>Booked transactions are final and cannot be edited.</span>
        <WarehouseItemTableComponent Items="transaction.AffectedItems.Where(it => it.ItemSchema == schema).ToList()"
                                     ItemStateSelectionFunc="it => transaction.NewItemStates!.First(st => st.Item == it)"
                                     PropertyColumns="new OrderedDictionary<string, bool>(GetItemPropertyColumns(schema)
                                     .Select(x => new KeyValuePair<string, bool>(x.propertyName, true)))" />
    }
    else if (transaction.State == TransactionState.DRAFT)
    {
        IEnumerable<InboundDraftItem> items = transaction.DraftItems.Where(it => it.CustomerId == customer.Id && it.ItemSchemaId == schema.Id);
        List<(string propertyName, Type propertyType)> propertyColumns = GetDraftItemPropertyColumns(schema);

        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    @foreach ((string propertyName, Type propertyType) propertyColumn in propertyColumns)
                    {
                        <th>@propertyColumn.propertyName</th>
                    }
                </tr>
            </thead>
            <tbody>
                @{
                    int tabIndex = 0;
                    foreach (InboundDraftItem item in items)
                    {
                        <tr>
                            @foreach ((string propertyName, Type propertyType) in propertyColumns)
                            {
                                <td>
                                    <InboundDraftItemPropertyValueInput DraftItem="@item"
                                                                        PropertyName="@propertyName"
                                                                        tabindex="@(tabIndex++)" />
                                </td>
                            }

                            <td>
                            </td>
                        </tr>
                    }

                    <tr>
                        @{
                            InboundDraftItem newItem = new InboundDraftItem
                            {
                                Customer = customer,
                                ItemSchema = schema,
                            };
                            foreach ((string propertyName, Type propertyType) propertyColumn in propertyColumns)
                            {
                                string propertyName = propertyColumn.propertyName;
                                <td>
                                    <InboundDraftItemPropertyValueInput DraftItem="@newItem"
                                                                        PropertyName="@propertyName"
                                                                        tabindex="@(tabIndex++)" />
                                </td>
                            }
                        }
                    </tr>
                }
            </tbody>
        </table>
    }
    else
    {
        throw new Exception("Unexpected transaction state: " + transaction.State);
    }
}

<div class="container-fluid">
    <h4>Add Customer with Schema</h4>
    <div class="row g-3">
        <div class="col-12 col-lg col-xxl-3 d-flex">
            <label for="customerToAdd" class="col-form-label me-1">Customer:</label>
            <CustomerPropertyValueInput @bind-Value="selectedCustomerToAdd" id="customerToAdd" />
        </div>
        <div class="col-12 col-lg col-xxl-3 d-flex">
            <label for="schemaToAdd" class="col-form-label me-1">Item&nbsp;Schema:</label>
            <InputSelect TValue="Guid" @bind-Value="selectedItemSchemaToAdd" class="form-select" id="schemaToAdd">
                <option value="@Guid.Empty"></option>
                @foreach (ItemSchema schema in selectedCustomerToAdd != null ? itemSchemas.Where(sch => sch.Customers.Any(cu => cu.Id == selectedCustomerToAdd.Id)) : [])
                {
                    <option value="@schema.Id">@schema.Name</option>
                }
            </InputSelect>
        </div>
        <div class="col-auto">
            <button @onclick="BtnAddSchemaOnClick" class="btn btn-primary">Add</button>
        </div>
    </div>
</div>

<FileAttachmentManagerComponent Attachments="@attachments"
                                OnAttachmentsUploaded="OnAttachmentsUploaded"
                                OnAttachmentRemoved="OnAttachmentRemoved" />