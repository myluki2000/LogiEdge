@using System.Reflection
@using System.Text.Json
@using System.Diagnostics.CodeAnalysis
@using LogiEdge.WarehouseService.Data
@using Microsoft.AspNetCore.Components.Forms
@inject NavigationManager NavigationManager
@code {
    [Parameter]
    public required IList<Item> Items { get; set; }

    /// <summary>
    /// Func which is used to determine which ItemState of the item is shown in the table.
    /// </summary>
    [Parameter]
    public required Func<Item, ItemState?> ItemStateSelectionFunc { get; set; }

    /// <summary>
    /// Ordered dictionary of the columns to display in the table. The Value in the dict is
    /// a bool which indicates whether the column should be visible or hidden.
    /// </summary>
    [Parameter]
    public required OrderedDictionary<string, bool> PropertyColumns
    {
        get => propertyColumns;
        [MemberNotNull(nameof(propertyColumns))]
        set
        {
            propertyColumns = value;
            modalPropertyColumns = new OrderedDictionary<string, bool>(PropertyColumns);
        }
    }

    /// <summary>
    /// Provides information about how the item list passed to the component is sorted.
    /// Pass NULL if item list is not sorted.
    /// </summary>
    [Parameter]
    public ColumnSortInfo? SortInfo { get; set; } = null;

    /// <summary>
    /// Set an action to this property which is run if the user clicks on a property value
    /// to filter the table by it. If no function is set, clicking on property values is disabled.
    /// </summary>
    [Parameter]
    public Action<(string propertyName, object? propertyValue)>? OnPropertyValueClicked { get; set; } = null;
    /// <summary>
    /// This function defines whether a property value of a property is clickable or not. If the value is clickable
    /// and is then clicked, the OnPropertyValueClicked action is run.
    /// </summary>
    [Parameter]
    public Func<(string propertyName, object? propertyValue), bool>? PropertyValueClickableFunc { get; set; } = null;
    /// <summary>
    /// Action which is run if the sort button of a column of the table is clicked. If set to NULL, sort buttons
    /// are hidden.
    /// </summary>
    [Parameter]
    public Action<ColumnSortInfo>? OnSortButtonClicked { get; set; } = null;
    /// <summary>
    /// Action which is run if the user clicks on the button to select which columns to show in the table.
    /// If set to NULL, the button is hidden.
    /// </summary>
    [Parameter]
    public Action<IEnumerable<string>>? OnColumnDisplaySelectionRequested { get; set; } = null!;
    /// <summary>
    /// Renders the render fragment as a footer row (RenderFragment should have root-level <tr></tr>) if
    /// set to non-null.
    /// </summary>
    [Parameter]
    public RenderFragment? FooterRow { get; set; } = null;

    private OrderedDictionary<string, bool>? modalPropertyColumns = null;
    private List<DraggableList<string>.ListItem> propertyListItems = [];

    private RenderFragment<(string propertyName, object? propertyValue)>? propertyRenderFragment = null;
    private OrderedDictionary<string, bool> propertyColumns;

    private void BtnSortClicked(string columnName)
    {
        // sort the column in ascending order if it is not already sorted by it
        bool descending = (SortInfo?.SortByColumn == columnName) && !(SortInfo?.SortOrderDescending ?? false);

        OnSortButtonClicked?.Invoke(new ColumnSortInfo(columnName, descending));
    }

    private void BtnCloseModalClicked()
    {
        OrderedDictionary<string, bool> properties = new((modalPropertyColumns ?? [])
            .OrderBy(x => propertyListItems.First(y => y.BackingElement == x.Key).Order).ToList());
        OnColumnDisplaySelectionRequested?.Invoke(properties.Where(x => x.Value).Select(x => x.Key).ToArray());
    }

    public class ColumnSortInfo
    {
        /// <summary>
        /// Name of the column the items are sorted by.
        /// </summary>
        public string SortByColumn { get; set; }
        /// <summary>
        /// If false, sorted in ascending order. If true, sorted in descending order
        /// </summary>
        public bool SortOrderDescending { get; set; }

        public ColumnSortInfo(string sortByColumn, bool sortOrderDescending)
        {
            SortByColumn = sortByColumn;
            SortOrderDescending = sortOrderDescending;
        }
    }
}

@{
    propertyRenderFragment = (ValueTuple<string, object?> data) => builder =>
    {
        (string propertyName, object? propertyValue) = data;

        if(PropertyValueClickableFunc != null)
        {
            
            <td>
                <a href="" @onclick="() => OnPropertyValueClicked?.Invoke((propertyName, propertyValue))">
                    <PropertyValueComponent PropertyValue="propertyValue"/>
                </a>
            </td>
        }
        else
        {
            <td>
                <PropertyValueComponent PropertyValue="propertyValue" />
            </td>
        }
    };
}

<span class="fst-italic">Showing @Items.Count items.</span>
<table class="table table-striped table-hover">
    <thead class="table-primary">
        <tr>
            @foreach ((string propertyName, bool _) in PropertyColumns.Where(x => x.Value))
            {
                <th style="line-height: 24px;">
                    <span style="vertical-align: bottom;">@propertyName</span>

                    @* render a sort button in the column header if the OnSortButtonClicked callback is set *@
                    @if (OnSortButtonClicked != null)
                    {
                        <button type="button"
                        class="btn btn-secondary table-button"
                        @onclick="() => BtnSortClicked(propertyName)">
                            @if (SortInfo?.SortByColumn == propertyName)
                            {
                                @if (SortInfo.SortOrderDescending)
                                {
                                    <span class="material-symbols-rounded">
                                        arrow_upward
                                    </span>
                                }
                                else
                                {
                                    <span class="material-symbols-rounded">
                                        arrow_downward
                                    </span>
                                }
                            }
                            else
                            {
                                <span class="material-symbols-rounded">
                                    swap_vert
                                </span>
                            }
                        </button>
                    }

                    @if (propertyName == PropertyColumns.Last(x => x.Value).Key)
                    {
                        @* button to select which columns to show *@
                        <button type="button"
                                class="btn btn-primary table-button"
                                style="float: right;"
                                data-bs-toggle="modal"
                                data-bs-target="#modal-column-select">
                            <span class="material-symbols-rounded">
                                splitscreen_vertical_add
                            </span>
                        </button>
                    }
                </th>
            }
        </tr>
    </thead>
    <tbody>
        @foreach (Item item in Items)
        {
            ItemState? itemState = ItemStateSelectionFunc.Invoke(item);

            @* if there is no item state before the given date that means the item wasn't in the warehouse at this 
            point in time, so skip it *@
            if (itemState == null)
                continue;

            <tr>
                @foreach (string propertyName in PropertyColumns.Where(x => x.Value).Select(x => x.Key))
                {
                    PropertyInfo? itemProperty = item.GetType().GetProperty(propertyName);
                    PropertyInfo? stateProperty = itemState.GetType().GetProperty(propertyName);
                    object? propertyValue = null;
                    if (itemProperty != null)
                    {
                        propertyValue = itemProperty.GetValue(item);
                    }
                    else if (stateProperty != null)
                    {
                        propertyValue = stateProperty?.GetValue(itemState);
                    }
                    else
                    {
                        // try finding it in the additional properties
                        // TODO: Support additional properties with non-string types
                        if (item.AdditionalProperties.RootElement.TryGetProperty(propertyName, out JsonElement propertyElement))
                            propertyValue = propertyElement.GetString();
                    }

                    @propertyRenderFragment((propertyName, propertyValue))
                }
            </tr>
        }

        @if (FooterRow != null)
        {
            @FooterRow
        }
    </tbody>
</table>

<div class="modal" id="modal-column-select" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Table Columns</h5>
                <button type="button"
                        class="btn-close"
                        data-bs-dismiss="modal"
                        aria-label="Close"
                        @onclick="BtnCloseModalClicked">
                </button>
            </div>
            <div class="modal-body">
                <p style="width: 100%; text-align: center;">Select columns to display in the table. Drag the handles to change column order.</p>
                <div id="modal-property-list" class="rounded border">
                    @{
                        RenderFragment<string> listItemFragment = item => @<span>
                            <InputCheckbox @bind-Value="modalPropertyColumns[item]" />
                            <label>@item</label>
                        </span>;
                        propertyListItems.Clear();
                        foreach (string propertyName in PropertyColumns.Keys)
                        {
                            propertyListItems.Add(new DraggableList<string>.ListItem
                {
                    Order = PropertyColumns.Keys.ToList().IndexOf(propertyName),
                    ListElement = listItemFragment,
                    BackingElement = propertyName
                });
                        }
                    }

                    <DraggableList TItem="string" Items="propertyListItems" Style="list-style-type: none;"></DraggableList>
                </div>
            </div>
        </div>
    </div>
</div>