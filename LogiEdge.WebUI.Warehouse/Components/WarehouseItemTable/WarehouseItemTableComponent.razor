@using System.Reflection
@using System.Text.Json
@using System.Diagnostics.CodeAnalysis
@using LogiEdge.CustomerService.Data
@using LogiEdge.Shared.Attributes
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Persistence
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore

@inject IDbContextFactory<WarehouseDbContext> WarehouseDbContextFactory

@code {
    [Parameter]
    public required Func<WarehouseDbContext, IQueryable<Item>> ItemsQueryableFactory { get; set; }

    [Parameter]
    public required ItemsTableColumnDisplayParameters ColumnDisplayParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableColumnDisplayParameters> ColumnDisplayParametersChanged { get; set; }

    [Parameter]
    public required ItemsTableFilterParameters FilterParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableFilterParameters> FilterParametersChanged { get; set; }

    [Parameter]
    public required ItemsTableSortParameters SortParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableSortParameters> SortParametersChanged { get; set; }

    [Parameter]
    public RenderFragment<(Item item, ItemState itemState, OrderedDictionary<string, object?> properties)>? TableRowRenderFragment { get; set; }

    private OrderedDictionary<string, bool> propertyColumns;

    private OrderedDictionary<string, bool> DisplayPropertyColumns { get; set; } = [];
    private List<ItemState> ItemsAtMoment { get; set; } = [];

    private string? _editingFilterProperty;

    private IReadOnlySet<ItemSchema> _itemSchemas;

    private void PropertyBadgeIsEditingChanged(string property, bool isEditing)
    {
        if (isEditing)
        {
            _editingFilterProperty = property;
        }
        else
        {
            if (property == _editingFilterProperty)
            {
                _editingFilterProperty = null;
            }
        }
    }

    private void BtnSortClicked(string columnName)
    {
        // sort the column in ascending order if it is not already sorted by it
        bool descending = (SortParameters.SortByProperty == columnName) && !SortParameters.SortOrderDescending;

        SortParameters = SortParameters with
        {
            SortByProperty = columnName,
            SortOrderDescending = descending,
        };

        SortParametersChanged.InvokeAsync(SortParameters);
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);

        ItemsTableFilter itemsTableFilter = new();

        await using WarehouseDbContext ctx = await WarehouseDbContextFactory.CreateDbContextAsync();

        IQueryable<Item> itemsQueryable = ItemsQueryableFactory.Invoke(ctx)
            .Include(it => it.ItemStates).ThenInclude(st => st.Warehouse)
            .Include(it => it.ItemStates).ThenInclude(st => st.Item).ThenInclude(it => it.Customer);

        IQueryable<ItemState> itemStatesQueryable = itemsTableFilter.Filter(itemsQueryable, FilterParameters);

        // get the used item schemas and extract the additional properties our items could have
        // When we get the schema entities directly, for some reason Distinct() does not work properly,
        // so we first get the distinct IDs and then query the schemas by their IDs.
        _itemSchemas = itemStatesQueryable
            .Select(st => st.Item.ItemSchemaId)
            .Distinct()
            .ToList()
            .Select(id => ctx.ItemSchemas.Include(sch => sch.AdditionalProperties).First(sch => sch.Id == id))
            .ToHashSet();
        List<string> schemasAdditionalProperties = _itemSchemas.SelectMany(sch => sch.AdditionalProperties).Select(pr => pr.Name).ToList();

        // get a list of column property names which are allowed
        List<string> allowedPropertyColumns = typeof(Item)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
            .Select(p => p.Name)
            .ToList();
        allowedPropertyColumns.AddRange(typeof(ItemState)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
            .Select(p => p.Name));
        allowedPropertyColumns.AddRange(schemasAdditionalProperties);

        DisplayPropertyColumns = [];

        foreach (string columnName in ColumnDisplayParameters.GetColumnsToDisplayOrDefault(_itemSchemas))
        {
            if (allowedPropertyColumns.Contains(columnName))
                DisplayPropertyColumns.Add(columnName, true);
        }

        foreach (string columnName in allowedPropertyColumns)
        {
            DisplayPropertyColumns.TryAdd(columnName, false);
        }

        // sort items
        ItemsTableSorter itemsSorter = new();
        ItemsAtMoment = itemsSorter.Sort(itemStatesQueryable.ToList(), SortParameters);
    }

    private async Task OnColumnsToDisplayChanged(OrderedDictionary<string, bool> columnsToDisplay)
    {
        ColumnDisplayParameters = ColumnDisplayParameters with
        {
            ColumnsToDisplay = columnsToDisplay.Where(col => col.Value).Select(col => col.Key).ToList()
        };
        await ColumnDisplayParametersChanged.InvokeAsync(ColumnDisplayParameters);
    }
}

@{
    TableRowRenderFragment ??=
        data => __builder =>
        {
            <tr>
                @foreach ((string propertyName, object? propertyValue) in data.properties)
                {
                    <td>
                        @switch (propertyName)
                        {
                            case nameof(Item.Id):
                                <a href="/warehouse/item/@data.item.Id">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            case nameof(Item.Customer):
                                Customer c = (Customer)propertyValue;
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(nameof(Item.Customer), c.Id))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            case nameof(ItemState.Warehouse):
                                Warehouse w = (Warehouse)propertyValue;
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(nameof(ItemState.Warehouse), w.Id))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            default:
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(propertyName, propertyValue.ToString()))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                        }
                    </td>
                }
            </tr>
        };
}

<div>
    Filter:
    @foreach (string property in ItemsTableFilterParameters.FilterableProperties)
    {
        <PropertyFilterBadgeComponent FilterParameters="FilterParameters"
                                      FilterParametersChanged="FilterParametersChanged"
                                      PropertyName="@property"
                                      PropertyType="FilterParameters.GetParameterType(_itemSchemas, property)"
                                      IsEditing="_editingFilterProperty == property"
                                      IsEditingChanged="isEditing => PropertyBadgeIsEditingChanged(property, isEditing)"/>
    }
</div>

<span class="fst-italic">Showing @(ItemsAtMoment.Count) items.</span>
<table class="table table-striped table-hover">
    <thead class="table-primary">
        <tr>
            @foreach ((string propertyName, bool _) in DisplayPropertyColumns.Where(x => x.Value))
            {
                <th style="line-height: 24px;">
                    <span style="vertical-align: bottom;">@propertyName</span>

                    <button type="button"
                            class="btn btn-secondary table-button"
                            @onclick="() => BtnSortClicked(propertyName)">
                        @if (SortParameters.SortByProperty == propertyName)
                        {
                            @if (SortParameters.SortOrderDescending)
                            {
                                <span class="material-symbols-rounded">
                                    arrow_upward
                                </span>
                            }
                            else
                            {
                                <span class="material-symbols-rounded">
                                    arrow_downward
                                </span>
                            }
                        }
                        else
                        {
                            <span class="material-symbols-rounded">
                                swap_vert
                            </span>
                        }
                    </button>

                    @if (propertyName == DisplayPropertyColumns.Last(x => x.Value).Key)
                    {
                        @* button to select which columns to show *@
                        <WarehouseItemTableColumnSelectionComponent class="btn btn-secondary table-button"
                                                                    ColumnsToDisplay="DisplayPropertyColumns"
                                                                    ColumnsToDisplayChanged="OnColumnsToDisplayChanged" />
                    }
                </th>
            }
        </tr>
    </thead>
    <tbody>
        @foreach (ItemState itemState in ItemsAtMoment)
        {
            Item item = itemState.Item;

            OrderedDictionary<string, object?> properties = new();

            @foreach (string propertyName in DisplayPropertyColumns.Where(x => x.Value).Select(x => x.Key))
            {
                PropertyInfo? itemProperty = item.GetType().GetProperty(propertyName);
                PropertyInfo? stateProperty = itemState.GetType().GetProperty(propertyName);
                object? propertyValue = null;
                if (itemProperty != null)
                {
                    propertyValue = itemProperty.GetValue(item);
                }
                else if (stateProperty != null)
                {
                    propertyValue = stateProperty?.GetValue(itemState);
                }
                else
                {
                    // try finding it in the additional properties
                    // TODO: Support additional properties with non-string types
                    if (item.AdditionalProperties.RootElement.TryGetProperty(propertyName, out JsonElement propertyElement))
                        propertyValue = propertyElement.GetString();
                }

                properties.Add(propertyName, propertyValue);
            }

            @TableRowRenderFragment((item, itemState, properties))
        }
    </tbody>
</table>

