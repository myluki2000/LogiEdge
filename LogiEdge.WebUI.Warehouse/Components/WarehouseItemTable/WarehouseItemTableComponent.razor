@using System.Reflection
@using System.Text.Json
@using LogiEdge.CustomerService.Data
@using LogiEdge.Shared.Attributes
@using LogiEdge.WarehouseService.Data
@using LogiEdge.WarehouseService.Persistence
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore

@inject IDbContextFactory<WarehouseDbContext> WarehouseDbContextFactory

@code {
    [Parameter]
    public required Func<WarehouseDbContext, IQueryable<Item>> ItemsQueryableFactory { get; set; }

    [Parameter]
    public required ItemsTableColumnDisplayParameters ColumnDisplayParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableColumnDisplayParameters> ColumnDisplayParametersChanged { get; set; }

    [Parameter]
    public required ItemsTableFilterParameters FilterParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableFilterParameters> FilterParametersChanged { get; set; }

    [Parameter]
    public required ItemsTableSortParameters SortParameters { get; set; }
    [Parameter]
    public EventCallback<ItemsTableSortParameters> SortParametersChanged { get; set; }

    [Parameter]
    public RenderFragment<(Item item, ItemState itemState, OrderedDictionary<string, object?> properties)>? TableRowRenderFragment { get; set; }

    [Parameter]
    public RenderFragment<(List<Item> items, List<ItemState> itemStates, OrderedDictionary<string, object?> properties)>? GroupedTableRowRenderFragment { get; set; }

    private OrderedDictionary<string, bool> DisplayPropertyColumnsSetting { get; set; } = [];

    private List<ItemState> ItemsAtMoment { get; set; } = [];

    private string? _editingFilterProperty;

    private IReadOnlySet<ItemSchema> _itemSchemas;

    private void PropertyBadgeIsEditingChanged(string property, bool isEditing)
    {
        if (isEditing)
        {
            _editingFilterProperty = property;
        }
        else
        {
            if (property == _editingFilterProperty)
            {
                _editingFilterProperty = null;
            }
        }
    }

    private void GroupByBadgeValueChanged(string property, bool newValue)
    {
        SortParameters = newValue
            ? SortParameters = SortParameters.WithGroupByProperty(property)
            : SortParameters = SortParameters.WithoutGroupByProperty(property);
        SortParametersChanged.InvokeAsync(SortParameters);
    }

    private void BtnSortClicked(string columnName)
    {
        // sort the column in ascending order if it is not already sorted by it
        bool descending = (SortParameters.SortByProperty == columnName) && !SortParameters.SortOrderDescending;

        SortParameters = SortParameters with
        {
            SortByProperty = columnName,
            SortOrderDescending = descending,
        };

        SortParametersChanged.InvokeAsync(SortParameters);
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);

        ItemsTableFilter itemsTableFilter = new();

        await using WarehouseDbContext ctx = await WarehouseDbContextFactory.CreateDbContextAsync();

        IQueryable<Item> itemsQueryable = ItemsQueryableFactory.Invoke(ctx)
            .Include(it => it.ItemStates).ThenInclude(st => st.Warehouse)
            .Include(it => it.ItemStates).ThenInclude(st => st.Item).ThenInclude(it => it.Customer);

        IQueryable<ItemState> itemStatesQueryable = itemsTableFilter.Filter(itemsQueryable, FilterParameters);

        // get the used item schemas and extract the additional properties our items could have
        // When we get the schema entities directly, for some reason Distinct() does not work properly,
        // so we first get the distinct IDs and then query the schemas by their IDs.
        _itemSchemas = itemStatesQueryable
            .Select(st => st.Item.ItemSchemaId)
            .Distinct()
            .ToList()
            .Select(id => ctx.ItemSchemas.Include(sch => sch.AdditionalProperties).First(sch => sch.Id == id))
            .ToHashSet();
        List<string> schemasAdditionalProperties = _itemSchemas.SelectMany(sch => sch.AdditionalProperties).Select(pr => pr.Name).ToList();

        // get a list of column property names which are allowed
        List<string> allowedPropertyColumns = typeof(Item)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
            .Select(p => p.Name)
            .ToList();
        allowedPropertyColumns.AddRange(typeof(ItemState)
            .GetProperties()
            .Where(p => Attribute.IsDefined(p, typeof(DisplayColumnPropertyAttribute)))
            .Select(p => p.Name));
        allowedPropertyColumns.AddRange(schemasAdditionalProperties);

        DisplayPropertyColumnsSetting = [];

        foreach (string columnName in ColumnDisplayParameters.GetColumnsToDisplayOrDefault(_itemSchemas))
        {
            if (allowedPropertyColumns.Contains(columnName))
                DisplayPropertyColumnsSetting.Add(columnName, true);
        }

        foreach (string columnName in allowedPropertyColumns)
        {
            DisplayPropertyColumnsSetting.TryAdd(columnName, false);
        }

        // sort items
        ItemsTableSorter itemsSorter = new();
        ItemsAtMoment = itemsSorter.Sort(itemStatesQueryable.ToList(), SortParameters);
    }

    private async Task OnColumnsToDisplayChanged(OrderedDictionary<string, bool> columnsToDisplay)
    {
        ColumnDisplayParameters = ColumnDisplayParameters with
        {
            ColumnsToDisplay = columnsToDisplay.Where(col => col.Value).Select(col => col.Key).ToList()
        };
        await ColumnDisplayParametersChanged.InvokeAsync(ColumnDisplayParameters);
    }
}

@{
    TableRowRenderFragment ??=
        data => __builder =>
        {
            <tr>
                @foreach ((string propertyName, object? propertyValue) in data.properties)
                {
                    <td>
                        @switch (propertyName)
                        {
                            case nameof(Item.Id):
                                <a href="/warehouse/item/@data.item.Id">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            case nameof(Item.Customer):
                                Customer c = (Customer)propertyValue;
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(nameof(Item.Customer), c.Id))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            case nameof(ItemState.Warehouse):
                                Warehouse w = (Warehouse)propertyValue;
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(nameof(ItemState.Warehouse), w.Id))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                            default:
                                <a href="javascript:void(0);"
                                   @onclick="() => FilterParametersChanged.InvokeAsync(FilterParameters.WithParameter(propertyName, propertyValue.ToString()))">
                                    <PropertyValueComponent PropertyValue="@propertyValue" />
                                </a>
                                break;
                        }
                    </td>
                }
            </tr>
        };

    GroupedTableRowRenderFragment ??=
        data => __builder =>
        {
            <tr>
                <td>@data.itemStates.Count</td>

                @foreach ((string propertyName, object? propertyValue) in data.properties)
                {
                    <td>
                        <PropertyValueComponent PropertyValue="@propertyValue" />
                    </td>
                }
            </tr>
        };

    List<string> propertyColumnsToDisplay = SortParameters.GroupByProperties.Length == 0
        ? DisplayPropertyColumnsSetting
            .Where(x => x.Value)
            .Select(x => x.Key)
            .ToList()
        : DisplayPropertyColumnsSetting
            .Where(x => x.Value)
            .Where(x => SortParameters.GroupByProperties.Contains(x.Key))
            .Select(x => x.Key)
            .ToList();
}

<div>
    Group By:
    @foreach (string property in ItemsTableFilterParameters.FilterableProperties)
    {
        <BadgeCheckboxComponent Value="SortParameters.GroupByProperties.Contains(property)"
                                ValueChanged="newValue => GroupByBadgeValueChanged(property, newValue)">
            @property
        </BadgeCheckboxComponent>
    }
</div>

<div>
    Filter:
    @foreach (string property in ItemsTableFilterParameters.FilterableProperties)
    {
        <PropertyFilterBadgeComponent FilterParameters="FilterParameters"
                                      FilterParametersChanged="FilterParametersChanged"
                                      PropertyName="@property"
                                      PropertyType="FilterParameters.GetParameterType(_itemSchemas, property)"
                                      IsEditing="_editingFilterProperty == property"
                                      IsEditingChanged="isEditing => PropertyBadgeIsEditingChanged(property, isEditing)" />
    }
</div>

<span class="fst-italic">Showing @(ItemsAtMoment.Count) items.</span>
<table class="table table-striped table-hover">
    <thead class="table-primary">
        <tr>
            @if (SortParameters.GroupByProperties.Length > 0)
            {
                <th style="line-height: 24px;">
                    <span style="vertical-align: bottom;">Count</span>
                </th>
            }

            @foreach (string propertyName in propertyColumnsToDisplay)
            {
                <th style="line-height: 24px;">
                    <span style="vertical-align: bottom;">@propertyName</span>

                    <button type="button"
                            class="btn btn-secondary table-button"
                            @onclick="() => BtnSortClicked(propertyName)">
                        @if (SortParameters.SortByProperty == propertyName)
                        {
                            @if (SortParameters.SortOrderDescending)
                            {
                                <span class="material-symbols-rounded">
                                    arrow_upward
                                </span>
                            }
                            else
                            {
                                <span class="material-symbols-rounded">
                                    arrow_downward
                                </span>
                            }
                        }
                        else
                        {
                            <span class="material-symbols-rounded">
                                swap_vert
                            </span>
                        }
                    </button>

                    @if (propertyName == propertyColumnsToDisplay.Last())
                    {
                        @* button to select which columns to show *@
                        <WarehouseItemTableColumnSelectionComponent class="btn btn-secondary table-button"
                                                                    ColumnsToDisplay="DisplayPropertyColumnsSetting"
                                                                    ColumnsToDisplayChanged="OnColumnsToDisplayChanged" />
                    }
                </th>
            }
        </tr>
    </thead>
    <tbody>
        @if (SortParameters.GroupByProperties.Length > 0)
        {
            ItemsTableGrouper itemsGrouper = new();
            List<IGrouping<ItemsTableGrouper.ItemGroupPropertiesValues, ItemState>> groupedItems = itemsGrouper.Group(ItemsAtMoment, SortParameters).ToList();

            @foreach (IGrouping<ItemsTableGrouper.ItemGroupPropertiesValues, ItemState> itemGroup in groupedItems)
            {
                OrderedDictionary<string, object?> properties = new();

                // only display properties which are activated as display properties and which at the same time exist in the
                // group key (i.e. the items were grouped by that property) - we can't display other properties here since the values
                // might be different for different items in the group
                @foreach (string propertyName in propertyColumnsToDisplay)
                {
                    object? propertyValue = itemGroup.Key[propertyName];
                    properties.Add(propertyName, propertyValue);
                }

                @GroupedTableRowRenderFragment((itemGroup.Select(st => st.Item).ToList(), itemGroup.ToList(), properties))
            }
        }
        else
        {
            @foreach (ItemState itemState in ItemsAtMoment)
            {
                Item item = itemState.Item;

                OrderedDictionary<string, object?> properties = new();

                @foreach (string propertyName in propertyColumnsToDisplay)
                {
                    PropertyInfo? itemProperty = item.GetType().GetProperty(propertyName);
                    PropertyInfo? stateProperty = itemState.GetType().GetProperty(propertyName);
                    object? propertyValue = null;
                    if (itemProperty != null)
                    {
                        propertyValue = itemProperty.GetValue(item);
                    }
                    else if (stateProperty != null)
                    {
                        propertyValue = stateProperty?.GetValue(itemState);
                    }
                    else
                    {
                        // try finding it in the additional properties
                        // TODO: Support additional properties with non-string types
                        if (item.AdditionalProperties.RootElement.TryGetProperty(propertyName, out JsonElement propertyElement))
                            propertyValue = propertyElement.GetString();
                    }

                    properties.Add(propertyName, propertyValue);
                }

                @TableRowRenderFragment((item, itemState, properties))
            }
        }
    </tbody>
</table>

